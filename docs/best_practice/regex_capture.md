Захват значений из регулярного выражения
========================================

При примении регулярного выражения к строке, можно не только выяснить, совпадает ли оно, но и сразу же выделить определенные значения.

Рассмотрим пример. Из строки вида `Artist/2010 - Album/track.mp3` нужно построить хеш вида:

```perl
{
    band   => 'Artist',
    year   => 2010,
    album  => 'Album',
    track  => 'track',
    format => 'mp3',
}
```

Будем пользоваться следущим регулярным выражением:

```perl
my $regex = qr{^([^/]+)/(\d+) - ([^/]+)/(.+)[.]([^.]+)$};
```

Захват с помощью переменных вида `$1`
-------------------------------------

```perl
$string =~ $regex;
my $hash = {
    band   => $1,
    year   => $2,
    album  => $3,
    track  => $4,
    format => $5,
};
```

Это наиболее прямой, но и наиболее нестабильный метод. Изменения регулярного выражения могут сказаться на том, какие значения в какую переменную будут записаны.

Захват с помощью возвращаемого значения оператора `=~`
------------------------------------------------------

Оператор `=~` в списочном контексте вернет все захваченные значения:

```perl
my ($band, $year, $album, $track, $format) = ($string =~ $regex);
my $hash = {
    band   => $band,
    year   => $year,
    album  => $album,
    track  => $track,
    format => $format,
};
```
Более того, поскольку хеш поддерживает срезы по множеству ключей, все еще проще:

```perl
my $hash = {};
@{$hash}{qw(band year album track format)} = ($string =~ $regex);
```

Этот способ все еще обладает недостатками предыдущего: позиция захватывающих скобок в регулярном выражении должна совпадает с позицией переменной, в которую происходит запись.

Захват с помощью `%+`
---------------------

Именованные скобки производят захват не в переменные вида `$1`, а в хеш `%+`. Воспользуемся этим:

```perl
$regex = qr{
  ^
    (?<band>[^/]+)
  /
    (?<year>\d+)
      [ ]-[ ]
    (?<album>[^/]+)
  /
    (?<track>.+)
      [.]
    (?<format>[^.]+)
  $
}x;

$string =~ $regex;
my $hash = {
    band   => $+{band},
    year   => $+{year},
    album  => $+{album},
    track  => $+{track},
    format => $+{format},
};
```

Легко видеть, что последнее выражение можно заменить на цикл:

```perl
my $hash = {};
$hash->{$_} = $+{$_} for qw(band year album track format);
```

Или, если мы уверены, что в `%+` нет ничего лишнего:

```perl
$hash->{$_} = $+{$_} for keys %+;

# или
$hash = { map {$_ => $+{$_}} keys %+ };

# или даже
$hash { %+ };
```

Этот вариант, пожалуй, наиболее стабилен и читаем.
